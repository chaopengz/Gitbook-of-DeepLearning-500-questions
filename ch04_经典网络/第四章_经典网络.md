[TOC]

# 第四章 经典网络
## 4.1 LeNet5

一种典型的用来识别数字的卷积网络是LeNet-5。
### 4.1.1 模型结构

![](./img/ch4/image1.png)

### 4.1.2 模型结构
LeNet-5共有7层（不包含输入层），每层都包含可训练参数；每个层有多个Feature Map，每个FeatureMap通过一种卷积滤波器提取输入的一种特征，然后每个FeatureMap有多个神经元。  

- C1层是一个卷积层  
  输入图片：32 \* 32  
  卷积核大小：5 \* 5 
  卷积核种类：6  
  输出featuremap大小：28 \* 28 （32-5+1）  
  神经元数量：28 \* 28 \* 6  
  可训练参数：（5 \* 5+1） \* 6（每个滤波器5 \* 5=25个unit参数和一个bias参数，一共6个滤波器）  
  连接数：（5 \* 5+1） \* 6 \* 28 \* 28  

- S2层是一个下采样层  
  输入：28 \* 28  
  采样区域：2 \* 2  
  采样方式：4个输入相加，乘以一个可训练参数，再加上一个可训练偏置。结果通过sigmoid  
  采样种类：6  
  输出featureMap大小：14 \* 14（28/2）  
  神经元数量：14 \* 14 \* 6  
  可训练参数：2 \* 6（和的权+偏置）  
  连接数：（2 \* 2+1） \* 6 \* 14 \* 14  
  S2中每个特征图的大小是C1中特征图大小的1/4  

- C3层也是一个卷积层  
  输入：S2中所有6个或者几个特征map组合  
  卷积核大小：5 \* 5  
  卷积核种类：16  
  输出featureMap大小：10 \* 10  
  C3中的每个特征map是连接到S2中的所有6个或者几个特征map的，表示本层的特征map是上一层提取到的特征map的不同组合  
  存在的一个方式是：C3的前6个特征图以S2中3个相邻的特征图子集为输入。接下来6个特征图以S2中4个相邻特征图子集为输入。然后的3个以不相邻的4个特征图子集为输入。最后一个将S2中所有特征图为输入。  则：可训练参数：6 \* （3 \* 25+1）+6 \* （4 \* 25+1）+3 \* （4 \* 25+1）+（25 \* 6+1）=1516  
  连接数：10 \* 10 \* 1516=151600  

- S4层是一个下采样层  
  输入：10 \* 10  
  采样区域：2 \* 2  
  采样方式：4个输入相加，乘以一个可训练参数，再加上一个可训练偏置。结果通过sigmoid  
  采样种类：16  
  输出featureMap大小：5 \* 5（10/2）  
  神经元数量：5 \* 5 \* 16=400  
  可训练参数：2 \* 16=32（和的权+偏置）  
  连接数：16 \* （2 \* 2+1） \* 5 \* 5=2000  
  S4中每个特征图的大小是C3中特征图大小的1/4 

- C5层是一个卷积层  
  输入：S4层的全部16个单元特征map（与s4全相连）  
  卷积核大小：5 \* 5 
  卷积核种类：120  
  输出featureMap大小：1 \* 1（5-5+1）  
  可训练参数/连接：120 \* （16 \* 5 \* 5+1）=48120  

- F6层全连接层  
  输入：c5 120维向量  
  计算方式：计算输入向量和权重向量之间的点积，再加上一个偏置，结果通过sigmoid函数  
  可训练参数:84 \* (120+1)=10164
### 4.1.3 模型特性
- 卷积网络使用一个3层的序列：卷积、池化、非线性——这可能是自这篇论文以来面向图像的深度学习的关键特性！
- 使用卷积提取空间特征
- 使用映射的空间均值进行降采样
- tanh或sigmoids非线性
- 多层神经网络（MLP）作为最终的分类器
- 层间的稀疏连接矩阵以避免巨大的计算开销

## 4.2 AlexNet

### 4.2.1 模型介绍

​	AlexNet在2012年ILSVRC竞赛中赢得了第一名，其Top5错误率为15.3%。AlexNet模型证明了CNN在复杂模型下的有效性，并且在可接受时间范围内，部署GPU得到了有效结果。

### 4.2.2 模型结构

![](./img/ch4/image2.jpeg)

### 4.2.3 模型解读

AlexNet共8层，前五层为卷积层，后三层为全连接层。

1. **conv1阶段**：

![](./img/ch4/image3.png)

&nbsp;&nbsp;

- 输入图片：227 \* 227 \* 3
- 卷积核大小：11* 11 *3
- 卷积核数量：96  
- 滤波器stride：4

- 输出featuremap大小：(227-11)/4+1=55 (227个像素减去11，然后除以4，生成54个像素，再加上被减去的11也对应生成一个像素)

- 输出featuremap大小：55 \* 55

- 共有96个卷积核，会生成55 \* 55 \* 96个卷积后的像素层。96个卷积核分成2组，每组48个卷积核。对应生成2组55 \* 55 \* 48的卷积后的像素层数据。

- 这些像素层经过relu1单元的处理，生成激活像素层，尺寸仍为2组55 \* 55 \* 48的像素层数据。 

- 这些像素层经过pool运算的处理，池化运算尺度为3 \* 3，运算的步长为2，则池化后图像的尺寸为(55-3)/2+1=27。 即池化后像素的规模为27 \* 27 \* 96；

- 然后经过归一化处理，归一化运算的尺度为5 \* 5；第一卷积层运算结束后形成的像素层的规模为27 \* 27 \* 96。分别对应96个卷积核所运算形成。这96层像素层分为2组，每组48个像素层，每组在一个独立的GPU上进行运算。  

- 反向传播时，每个卷积核对应一个偏差值。即第一层的96个卷积核对应上层输入的96个偏差值。


2. **conv2阶段**：

![](./img/ch4/image4.png)

&nbsp;&nbsp;&nbsp;&nbsp;

- 输入图片：27 \* 27 \* 96（第一层输出）
- 为便于后续处理，每幅像素层的左右两边和上下两边都要填充2个像素
- 27 \* 27 \* 96的像素数据分成27 \* 27 \* 48的两组像素数据，两组数据分别再两个不同的GPU中进行运算。
- 卷积核大小：5 \* 5 \* 48
- 滤波器stride：1

- 输出featuremap大小：卷积核在移动的过程中会生成(27-5+2 \* 2)/1+1=27个像素。(27个像素减去5，正好是22，在加上上下、左右各填充的2个像素，即生成26个像素，再加上被减去的5也对应生成一个像素)，行和列的27 \* 27个像素形成对原始图像卷积之后的像素层。共有256个5 \* 5 \* 48卷积核；这256个卷积核分成两组，每组针对一个GPU中的27 \* 27 \* 48的像素进行卷积运算。会生成两组27 \* 27 \* 128个卷积后的像素层。

- 这些像素层经过relu2单元的处理，生成激活像素层，尺寸仍为两组27 \* 27 \* 128的像素层。  

- 这些像素层经过pool运算(池化运算)的处理，池化运算的尺度为3 \* 3，运算的步长为2，则池化后图像的尺寸为(57-3)/2+1=13。 即池化后像素的规模为2组13 \* 13 \* 128的像素层；

- 然后经过归一化处理，归一化运算的尺度为5 \* 5；

- 第二卷积层运算结束后形成的像素层的规模为2组13 \* 13 \* 128的像素层。分别对应2组128个卷积核所运算形成。每组在一个GPU上进行运算。即共256个卷积核，共2个GPU进行运算。  

- 反向传播时，每个卷积核对应一个偏差值。即第一层的96个卷积核对应上层输入的256个偏差值。


3. **conv3阶段**：

![](./img/ch4/image5.png)

- 第三层输入数据为第二层输出的2组13 \* 13 \* 128的像素层；
- 为便于后续处理，每幅像素层的左右两边和上下两边都要填充1个像素；
- 2组像素层数据都被送至2个不同的GPU中进行运算。每个GPU中都有192个卷积核，每个卷积核的尺寸是3 \* 3 \* 256。因此，每个GPU中的卷积核都能对2组13 \* 13 \* 128的像素层的所有数据进行卷积运算。
- 移动的步长是1个像素。
- 运算后的卷积核的尺寸为(13-3+1 \* 2)/1+1=13（13个像素减去3，正好是10，在加上上下、左右各填充的1个像素，即生成12个像素，再加上被减去的3也对应生成一个像素），每个GPU中共13 \* 13 \* 192个卷积核。2个GPU中共13 \* 13 \* 384个卷积后的像素层。这些像素层经过relu3单元的处理，生成激活像素层，尺寸仍为2组13 \* 13 \* 192像素层，共13 \* 13 \* 384个像素层。



4. **conv4阶段DFD**：

![](./img/ch4/image6.png)

&nbsp;&nbsp;&nbsp;&nbsp; 

- 第四层输入数据为第三层输出的2组13 \* 13 \* 192的像素层；

- 为便于后续处理，每幅像素层的左右两边和上下两边都要填充1个像素；

- 2组像素层数据都被送至2个不同的GPU中进行运算。每个GPU中都有192个卷积核，每个卷积核的尺寸是3 \* 3 \* 192。因此，每个GPU中的卷积核能对1组13 \* 13 \* 192的像素层的数据进行卷积运算。

- 移动的步长是1个像素。

- 运算后的卷积核的尺寸为(13-3+1 \* 2)/1+1=13（13个像素减去3，正好是10，在加上上下、左右各填充的1个像素，即生成12个像素，再加上被减去的3也对应生成一个像素），每个GPU中共13 \* 13 \* 192个卷积核。2个GPU中共13 \* 13 \* 384个卷积后的像素层。

- 这些像素层经过relu4单元的处理，生成激活像素层，尺寸仍为2组13 \* 13 \* 192像素层，共13 \* 13 \* 384个像素层。


 5. **conv5阶段**：

 ![](./img/ch4/image7.png)

&nbsp;&nbsp;&nbsp;&nbsp; 

- 第五层输入数据为第四层输出的2组13 \* 13 \* 192的像素层；
- 为便于后续处理，每幅像素层的左右两边和上下两边都要填充1个像素；
- 2组像素层数据都被送至2个不同的GPU中进行运算。每个GPU中都有128个卷积核，每个卷积核的尺寸是3 \* 3 \* 192。因此，每个GPU中的卷积核能对1组13 \* 13 \* 192的像素层的数据进行卷积运算。
- 移动的步长是1个像素。
- 因此，运算后的卷积核的尺寸为(13-3+1 \* 2)/1+1=13（13个像素减去3，正好是10，在加上上下、左右各填充的1个像素，即生成12个像素，再加上被减去的3也对应生成一个像素），每个GPU中共13 \* 13 \* 128个卷积核。2个GPU中共13 \* 13 \* 256个卷积后的像素层。
- 这些像素层经过relu5单元的处理，生成激活像素层，尺寸仍为2组13 \* 13 \* 128像素层，共13 \* 13 \* 256个像素层。
- 2组13 \* 13 \* 128像素层分别在2个不同GPU中进行池化(pool)运算处理。池化运算的尺度为3 \* 3，运算的步长为2，则池化后图像的尺寸为(13-3)/2+1=6。 即池化后像素的规模为两组6 \* 6 \* 128的像素层数据，共6 \* 6 \* 256规模的像素层数据。




6. **fc6阶段**：

![](./img/ch4/image8.png)

&nbsp;&nbsp;&nbsp;&nbsp;

- 第六层输入数据的尺寸是6 \* 6 \* 256
- 采用6 \* 6 \* 256尺寸的滤波器对第六层的输入数据进行卷积运算
- 共有4096个6 \* 6 \* 256尺寸的滤波器对输入数据进行卷积运算，通过4096个神经元输出运算结果；
- 这4096个运算结果通过relu激活函数生成4096个值；
- 通过drop运算后输出4096个本层的输出结果值。
- 由于第六层的运算过程中，采用的滤波器的尺寸(6 \* 6 \* 256)与待处理的feature map的尺寸(6 \* 6 \* 256)相同，即滤波器中的每个系数只与feature map中的一个像素值相乘；而其它卷积层中，每个滤波器的系数都会与多个feature map中像素值相乘；因此，将第六层称为全连接层。 
-  第五层输出的6 \* 6 \* 256规模的像素层数据与第六层的4096个神经元进行全连接，然后经由relu6进行处理后生成4096个数据，再经过dropout6处理后输出4096个数据。



7. **fc7阶段**：

![](./img/ch4/image9.png)



- 第六层输出的4096个数据与第七层的4096个神经元进行全连接
- 然后经由relu7进行处理后生成4096个数据，再经过dropout7处理后输出4096个数据。



8. **fc8阶段**：

![](./img/ch4/image10.png)

&nbsp;&nbsp;&nbsp;&nbsp;

- 第七层输出的4096个数据与第八层的1000个神经元进行全连接，经过训练后输出被训练的数值。


### 4.2.4 模型特性
- 使用ReLU作为非线性

- 使用dropout技术选择性地忽略训练中的单个神经元，避免模型的过拟合

- 重叠最大池化（overlapping max pooling），避免平均池化（average pooling）的平均效应

- 使用NVIDIA GTX 580 GPU减少训练时间

- 当时，GPU比CPU提供了更多的核心，可以将训练速度提升10倍，从而允许使用更大的数据集和更大的图像。



## 4.3 可视化ZFNet-转置卷积
### 4.3.1 基本的思想及其过程

- 可视化技术揭露了激发模型中每层单独的特征图。
- 可视化技术允许观察在训练阶段特征的演变过程且诊断出模型的潜在问题。
- 可视化技术用到了多层解卷积网络，即由特征激活返回到输入像素空间。
- 可视化技术进行了分类器输出的敏感性分析，即通过阻止部分输入图像来揭示那部分对于分类是重要的。
- 可视化技术提供了一个非参数的不变性来展示来自训练集的哪一块激活哪个特征图，不仅需要裁剪输入图片，而且自上而下的投影来揭露来自每块的结构激活一个特征图。
- 可视化技术依赖于解卷积操作，即卷积操作的逆过程，将特征映射到像素上。

### 4.3.2 卷积与转置卷积

&nbsp;&nbsp;&nbsp;&nbsp;
下图为卷积过程 

<center>
    <img src="./img/ch4/image11.GIF"/>
    <img src="./img/ch4/image12.png"/>
</center>
&nbsp;&nbsp;&nbsp;&nbsp;
下图为转置卷积过程

<center>
    <img src="./img/ch4/image13.png"/>
    <img src="./img/ch4/image14.png"/>
</center>
&nbsp;&nbsp;&nbsp;&nbsp;

下面首先介绍转置卷积中涉及到的几种操作：

**反池化操作**：池化操作是非可逆的，但是我们可以用一组转换变量switch在每个池化区域中通过记录最大值的位置来获得一个近似值。在转置卷积网络中，反池化操作使用这些转换来放置上述最大值的位置，保存激活的位置，其余位置都置0。

**激活函数**：卷积网中使用非线性的ReLU来确保所有输出值总是正值。在反卷积网中也利用了ReLU。

**转置卷积**：为了实现转置卷积，转置卷积网络使用相同卷积核的转置作为新的卷积核进行计算。

![](./img/ch4/image15.jpeg)  

&nbsp;&nbsp;&nbsp;&nbsp;
​	上图左半部分是一个转置卷积层，右半部分为一个卷积层。反卷积层将会重建一个来自下一层的卷积特征近似版本。图中使用switch来记录在卷积网中进行最大池化操作时每个池化区域的局部最大值的位置，经过非池化操作之后，原来的非最大值的位置都置为0。

### 4.3.3 卷积可视化
&nbsp;&nbsp;&nbsp;&nbsp;
​	预处理：网络对输入图片进行预处理，裁剪图片中间的256x256区域，并减去整个图像每个像素的均值，然后用10个不同的对256x256图像进行224x224的裁剪（中间区域加上四个角落，以及他们的水平翻转图像），对以128个图片分的块进行随机梯度下降法来更新参数。起始学习率为0.01，动量为0.9，当验证集误差不再变化时时，手动调整学习率。在全连接网络中使用概率为0.5的dropout，并且所有权值都初始化为0.01，偏置设为0。

&nbsp;&nbsp;&nbsp;&nbsp;
​	特征可视化：当输入存在一定的变化时，网络的输出结果保持不变。下图即在一个已经训练好的网络中可视化后的图。在可视化结果的右边是对应的输入图片，与重构特征相比，输入图片之间的差异性很大，而重构特征只包含那些具有判别能力的纹理特征。

![](./img/ch4/image18.jpeg)  

&nbsp;&nbsp;&nbsp;&nbsp;
​	由上图可以看到第二层应对角落和其他边缘或者颜色的结合；第三层有更加复杂的不变性，捕捉到了相似的纹理；第四层显示了特定类间显著的差异性；第五层显示了有显著构成变化的整个物体。

&nbsp;&nbsp;&nbsp;&nbsp;
​	训练时的特征演变过程：当输入图片中的最强刺激源发生变化时，对应的输出特征轮廓发生剧烈变化。经过一定次数的迭代以后，底层特征趋于稳定，但更高层的特征则需要更多的迭代次数才能收敛，这表明：只有所有层都收敛时，这个分类模型才是有效的。

![](./img/ch4/image19.jpeg)  

&nbsp;&nbsp;&nbsp;&nbsp;
​	**特征不变性:** 一般来说，就深度模型来说，只要深度超过七层，微小的变化对于模型的第一层都有比较大的影响，但对于较深层几乎没有没有影响。对于图像的平移、尺度、旋转的变化来说，网络的输出对于平移和尺度变化都是稳定的，但却不具有旋转不变性，除非目标图像时旋转对称的。下图为分别对平移，尺度，旋转做的分析图。 

![](./img/ch4/image20.jpeg)  

&nbsp;&nbsp;&nbsp;&nbsp;
​	上图按行顺序分别为对5类图像进行不同程度的垂直方向上的平移、尺度变换、旋转对输出结果影响的分析图。按列顺序分别为原始变换图像，第一层中原始图片和变换后的图片的欧氏距离，第7层中原始图片和变换后的图片的欧氏距离，变换后图片被正确分类的概率图。    

&nbsp;&nbsp;&nbsp;&nbsp;
​	可视化不仅能够看到一个训练完的模型的内部操作，而且还能帮助选择好的网络结构。   

### 4.3.4 ZFNet和AlexNet比较

&nbsp;&nbsp;&nbsp;&nbsp;
​	ZFNet的网络结构实际上与AlexNet没有什么很大的变化，差异表现在AlexNet用了两块GPU的稀疏连接结构，而ZFNet只用了一块GPU的稠密连接结构；同时，由于可视化可以用来选择好的网络结构，通过可视化发现AlexNet第一层中有大量的高频和低频信息的混合，却几乎没有覆盖到中间的频率信息；且第二层中由于第一层卷积用的步长为4太大了，导致了有非常多的混叠情况；因此改变了AlexNet的第一层即将滤波器的大小11x11变成7x7，并且将步长4变成了2，下图为AlexNet网络结构与ZFNet的比较。

![](./img/ch4/image2.jpeg)
![](./img/ch4/image21.jpeg)


## 4.4 VGGNet
### 4.4.1 模型结构

![](./img/ch4/image22.jpeg)

### 4.4.2 模型特点


1. 整个网络都使用了同样大小的卷积核尺寸（3 \* 3）和最大池化尺寸（2 \* 2）
2. 1 \* 1卷积的意义主要在于线性变换，而输入通道数和输出通道数不变，没有发生降维。
3. 两个3 \* 3的卷积层串联相当于1个5 \* 5的卷积层，即一个像素会跟周围5 \* 5的像素产生关联，可以说感受野大小为5 \* 5。而3个3 \* 3的卷积层串联的效果则相当于1个7 \* 7的卷积层。除此之外，3个串联的3 \* 3的卷积层，拥有比1个7 \* 7的卷积层更少的参数量，只有后者的(3 \* 3 \* 3)/(7 \* 7)=55%。最重要的是，3个3 \* 3的卷积层拥有比1个7 \* 7的卷积层更多的非线性变换（前者可以使用三次ReLU激活函数，而后者只有一次），使得CNN对特征的学习能力更强。
4. VGGNet在训练时有一个小技巧，先训练级别A的简单网络，再复用A网络的权重来初始化后面的几个复杂模型，这样训练收敛的速度更快。在预测时，VGG采用Multi-Scale的方法，将图像scale到一个尺寸Q，并将图片输入卷积网络计算。然后在最后一个卷积层使用滑窗的方式进行分类预测，将不同窗口的分类结果平均，再将不同尺寸Q的结果平均得到最后结果，这样可提高图片数据的利用率并提升预测准确率。在训练中，VGGNet还使用了Multi-Scale的方法做数据增强，将原始图像缩放到不同尺寸S，然后再随机裁切224*224的图片，这样能增加很多数据量，对于防止模型过拟合有很不错的效果。

## 4.5 Network in Network
### 4.5.1 模型结构

![](./img/ch4/image23.jpeg)

### 4.5.2 模型创新点

&nbsp;&nbsp;&nbsp;&nbsp;
论文的创新点：

1. 提出了抽象能力更高的Mlpconv层
2. 提出了Global Average Pooling（全局平均池化）层

- Mlpconv层 <br>
    &nbsp;&nbsp;&nbsp;&nbsp;
    传统的卷积神经网络一般来说是由线性卷积层、池化层、全连接层堆叠起来的网络，卷积层通过线性滤波器进行线性卷积运算，然后在接个非线性激活函数最终生成特征图。而这种卷积滤波器是一种GLM:(Generalized linear model)广义线性模型。然而GLM的抽象能力是比较低水平的。 

    &nbsp;&nbsp;&nbsp;&nbsp;
    抽象：指得到对同一概念的不同变体保持不变的特征。

    &nbsp;&nbsp;&nbsp;&nbsp;
    一般用CNN进行特征提取时，其实就隐含地假设了特征是线性可分的，可实际问题往往是难以线性可分的。一般来说我们所要提取的特征一般是高度非线性的。在传统的CNN中，也许我们可以用超完备的滤波器，来提取各种潜在的特征。比如我们要提取某个特征，于是我就用了一大堆的滤波器，把所有可能的提取出来，这样就可以把我想要提取的特征也覆盖到，然而这样存在一个缺点，那就是网络太恐怖了，参数太多了。 

&nbsp;&nbsp;&nbsp;&nbsp;
我们知道CNN高层特征其实是低层特征通过某种运算的组合。所以论文就根据这个想法，提出在每个局部感受野中进行更加复杂的运算，提出了对卷积层的改进算法：MLP卷积层。（这里也不知道是否有道理，因为在后面的深层网络没有提出此种说法，还是按照传统的cnn方法使用多个滤波器去学习同一特征的不同变体）。MLP中的激活函数采用的是整流线性单元（即ReLU:max（wx+b,0)。 
MLP的优点： 

1. 非常有效的通用函数近似器 
2. 可用BP算法训练，可以完美地融合进CNN 
3. 其本身也是一种深度模型，可以特征再利用 

<center><img src="./img/ch4/image24.png"/></center>

- 全局平均池化层 
  
    &nbsp;&nbsp;&nbsp;&nbsp;
    另一方面，传统的CNN最后一层都是全连接层，参数个数非常之多，容易引起过拟合（如Alexnet），一个CNN模型，大部分的参数都被全连接层给占用了，所以论文提出采用了全局均值池化替代全连接层。与传统的全连接层不同，我们对每个特征图一整张图片进行全局均值池化，这样每张特征图都可以得到一个输出。这样采用均值池化，连参数都省了，可以大大减小网络参数，避免过拟合，另一方面它有一个特点，每张特征图相当于一个输出特征，然后这个特征就表示了我们输出类的特征。
    <br>
    全局平均池化的优势： 
    1. 通过加强特征图与类别的一致性，让卷积结构更简单 
    2. 不需要进行参数优化，所以这一层可以避免过拟合 
    3. 它对空间信息进行了求和，因而对输入的空间变换更具有稳定性

&nbsp;&nbsp;&nbsp;&nbsp;
在采用了微神经网络后，让局部模型有更强的抽象能力，从而让全局平均池化能具有特征图与类别之间的一致性，同时相比传统CNN采用的全连接层，不易过拟合（因为全局平均池化本身就是一种结构性的规则项）（PS:经典CNN容易过拟合，并严重依赖用dropout进行规则化）。

## 4.6 GoogleNet
### 4.6.1 模型结构
![](./img/ch4/image25.jpeg)
![](./img/ch4/image26.png)

### 4.6.2 Inception 结构

![](./img/ch4/image27.jpeg)

对上图做以下说明：

1. 采用不同大小的卷积核意味着不同大小的感受野，最后拼接意味着不同尺度特征的融合； 
2. 之所以卷积核大小采用1、3和5，主要是为了方便对齐。设定卷积步长stride=1之后，只要分别设定pad=0、1、2，那么卷积之后便可以得到相同维度的特征，然后这些特征就可以直接拼接在一起了；
3. 文章说很多地方都表明pooling挺有效，所以Inception里面也嵌入了。 
4. 网络越到后面，特征越抽象，而且每个特征所涉及的感受野也更大了，因此随着层数的增加，3x3和5x5卷积的比例也要增加。

但是，使用5x5的卷积核仍然会带来巨大的计算量。 为此，文章借鉴NIN2，采用1x1卷积核来进行降维。

例如：上一层的输出为100x100x128，经过具有256个输出的5x5卷积层之后(stride=1，padding=2)，输出数据为100x100x256。其中，卷积层的参数为128x5x5x256。假如上一层输出先经过具有32个输出的1x1卷积层，再经过具有256个输出的5x5卷积层，那么最终的输出数据仍为为100x100x256，但卷积参数量已经减少为128x1x1x32 + 32x5x5x256，大约减少了4倍。

具体改进后的Inception Module如下图：

![](./img/ch4/image28.jpeg)

## 4.7 Inception 系列
### 4.7.1 Inception v1

&nbsp;&nbsp;&nbsp;&nbsp;
相比于GoogLeNet之前的众多卷积神经网络而言，inception v1采用在同一层中提取不同的特征（使用不同尺寸的卷积核），并提出了卷积核的并行合并（也称为Bottleneck layer），如下图

![](./img/ch4/image31.png)

这样的结构主要有以下改进：
1. 一层block就包含1x1卷积，3x3卷积，5x5卷积，3x3池化(使用这样的尺寸不是必需的，可以根据需要进行调整)。这样，网络中每一层都能学习到“稀疏”（3x3. 5x5）或“不稀疏”（1x1）的特征，既增加了网络的宽度，也增加了网络对尺度的适应性；
2. 通过deep concat在每个block后合成特征，获得非线性属性。

虽然这样提高了性能，但是网络的计算量实在是太大了，因此GoogLeNet借鉴了Network-in-Network的思想，使用1x1的卷积核实现降维操作，以此来减小网络的参数量(这里就不对两种结构的参数量进行定量比较了)，如图所示。

![](./img/ch4/image32.png) 

&nbsp;&nbsp;&nbsp;&nbsp;
最后实现的inception v1网络是上图结构的顺序连接，其中不同inception模块之间使用2x2的最大池化进行下采样，如表所示。

![](./img/ch4/image33.png) 

如表所示，实现的网络仍有一层全连接层，该层的设置是为了迁移学习的实现（下同）。
在之前的网络中，最后都有全连接层，经实验证明，全连接层并不是很必要的，因为可能会带来以下三点不便：
​    - 网络的输入需要固定
​    - 参数量多
​    - 易发生过拟合
实验证明，将其替换为平均池化层（或者1x1卷积层）不仅不影响精度，还可以减少。

### 4.7.2 Inception v2

在V1的基础之上主要做了以下改进：

- 使用BN层，将每一层的输出都规范化到一个N(0,1)的正态分布，这将有助于训练，因为下一层不必学习输入数据中的偏移，并且可以专注与如何更好地组合特征（也因为在v2里有较好的效果，BN层几乎是成了深度网络的必备）；
&nbsp;&nbsp;&nbsp;&nbsp;
（在Batch-normalized论文中只增加了BN层，而之后的Inception V3的论文提及到的inception v2还做了下面的优化）

- 使用2个3x3的卷积代替梯度（特征图，下同）为35x35中的5x5的卷积，这样既可以获得相同的视野(经过2个3x3卷积得到的特征图大小等于1个5x5卷积得到的特征图)，还具有更少的参数，还间接增加了网络的深度，如下图。

![](./img/ch4/image34.png) 
![](./img/ch4/image35.png) 

- 3x3的卷积核表现的不错，那更小的卷积核是不是会更好呢？比如2x2。对此，v2在17x17的梯度中使用1 \* n和n \* 1这种非对称的卷积来代替n \* n的对称卷积，既降低网络的参数，又增加了网络的深度（实验证明，该结构放于网络中部，取n=7，准确率更高），如下。（基于原则3）

<center>
    <img src="./img/ch4/image36.png"/>
    <img src="./img/ch4/image37.png"/>
</center>

- 在梯度为8x8时使用可以增加滤波器输出的模块（如下图），以此来产生高维的稀疏特征。

![](./img/ch4/image38.png) 

- 输入从224x224变为229x229。

最后实现的Inception v2的结构如下表。

![](./img/ch4/image39.png) 


&nbsp;&nbsp;&nbsp;&nbsp;
经过网络的改进，inception v2得到更低的识别误差率，与其他网络识别误差率对比如表所示。

![](./img/ch4/image40.png) 

&nbsp;&nbsp;&nbsp;&nbsp;
如表，inception v2相比inception v1在imagenet的数据集上，识别误差率由29%降为23.4%。

### 4.7.3 Inception v3

&nbsp;&nbsp;&nbsp;&nbsp;
inception模块之间特征图的缩小，主要有下面两种方式：

![](./img/ch4/image41.png) 

&nbsp;&nbsp;&nbsp;&nbsp;
右图是先进行inception操作，再进行池化来下采样，但是这样参数量明显多于左图(比较方式同前文的降维后inception模块)，因此v2采用的是左图的方式，即在不同的inception之间（35/17/8的梯度）采用池化来进行下采样。

&nbsp;&nbsp;&nbsp;&nbsp;
但是，左图这种操作会造成表达瓶颈问题，也就是说特征图的大小不应该出现急剧的衰减(只经过一层就骤降)。如果出现急剧缩减，将会丢失大量的信息，对模型的训练造成困难。
&nbsp;&nbsp;&nbsp;&nbsp;
因此，在2015年12月提出的Inception V3结构借鉴inception的结构设计了采用一种并行的降维结构，如下图：

![](./img/ch4/image42.png) 

&nbsp;&nbsp;&nbsp;&nbsp;具体来说，就是在35/17/8之间分别采用下面这两种方式来实现特征图尺寸的缩小，如下图：

![](./img/ch4/image43.png) 

figure 5'   35/17之间的特征图尺寸减小

![](./img/ch4/image44.png) 

figure 6' 17/8之间的特征图尺寸缩小

这样就得到Inception v3的网络结构，如表所示。

![](./img/ch4/image45.png) 

### 4.7.4 Inception V4

&nbsp;&nbsp;&nbsp;&nbsp;
其实，做到现在，Inception模块感觉已经做的差不多了，再做下去准确率应该也不会有大的改变。但是谷歌这帮人还是不放弃，非要把一个东西做到极致，改变不了Inception模块，就改变其他的。

&nbsp;&nbsp;&nbsp;&nbsp;
因此，作者Christian Szegedy设计了Inception v4的网络，将原来卷积、池化的顺次连接（网络的前几层）替换为stem模块，来获得更深的网络结构。stem模块结构如下：

![](./img/ch4/image46.png) 
<center>stem模块</center>

![](./img/ch4/image47.png) 

&nbsp;&nbsp;&nbsp;&nbsp;
Inception v4 中的Inception模块（分别为Inception A Inception B Inception C）

![](./img/ch4/image48.png) 

&nbsp;&nbsp;&nbsp;&nbsp;
Inception v4中的reduction模块（分别为reduction A reduction B）

&nbsp;&nbsp;&nbsp;&nbsp;
最终得到的Inception v4结构如下图。

### 4.7.5 Inception-ResNet-v2

&nbsp;&nbsp;&nbsp;&nbsp;
ResNet的结构既可以加速训练，还可以提升性能（防止梯度消失）；Inception模块可以在同一层上获得稀疏或非稀疏的特征。有没有可能将两者进行优势互补呢？

&nbsp;&nbsp;&nbsp;&nbsp;
Christian Szegedy等人将两个模块的优势进行了结合，设计出了Inception-ResNet网络。

&nbsp;&nbsp;&nbsp;&nbsp;
(Inception-ResNet有v1和v2两个版本，v2表现更好且更复杂，这里只介绍了v2)

&nbsp;&nbsp;&nbsp;&nbsp;
Inception-ResNet的成功，主要是它的Inception-ResNet模块。

&nbsp;&nbsp;&nbsp;&nbsp;
Inception-ResNet v2中的Inception-ResNet模块如下图：

![](./img/ch4/image49.png) 

&nbsp;&nbsp;&nbsp;&nbsp;
Inception-ResNet模块（分别为Inception-ResNet-A Inception-ResNet-B Inception-ResNet-C）

&nbsp;&nbsp;&nbsp;&nbsp;
Inception-ResNet模块之间特征图尺寸的减小如下图。（类似于Inception v4）

![](./img/ch4/image50.png) 

&nbsp;&nbsp;&nbsp;&nbsp;
Inception-ResNet-v2中的reduction模块（分别为reduction A reduction B）

&nbsp;&nbsp;&nbsp;&nbsp;
最终得到的Inception-ResNet-v2网络结构如图(stem模块同Inception v4)。
![](./img/ch4/image63.png) 

## 4.8 ResNet及其变体

&nbsp;&nbsp;&nbsp;&nbsp;
自从AlexNet在LSVRC2012分类比赛中取得胜利之后，深度残差网络（Deep Residual Network）可以说成为过去几年中，在计算机视觉、深度学习社区领域中最具突破性的成果了。ResNet可以实现高达数百，甚至数千个层的训练，且仍能获得超赞的性能。

&nbsp;&nbsp;&nbsp;&nbsp;
得益于其强大的表征能力，许多计算机视觉应用在图像分类以外领域的性能得到了提升，如对象检测和人脸识别。

&nbsp;&nbsp;&nbsp;&nbsp;
自从2015年ResNet进入人们的视线，并引发人们思考之后，许多研究界人员已经开始研究其成功的秘诀，并在架构中纳入了许多新的改进。本文分为两部分，第一部分我将为那些不熟悉ResNet的人提供一些相关的背景知识，第二部分我将回顾一些我最近读过的关于ResNet架构的不同变体及其论文的相关阐述。
### 4.8.1 重新审视ResNet
&nbsp;&nbsp;&nbsp;&nbsp;
根据泛逼近性原理（universal approximation theorem），我们知道，如果给定足够的容量，一个具有单层的前馈网络足以表示任何函数。然而，该层可能是巨大的，且网络可能容易过度拟合数据。因此，研究界有一个共同的趋势，即我们的网络架构需要更深。

&nbsp;&nbsp;&nbsp;&nbsp;
自从AlexNet投入使用以来，最先进的卷积神经网络（CNN）架构越来越深。虽然AlexNet只有5层卷积层，但VGG网络和GoogleNet（代号也为Inception_v1）分别有19层和22层。

&nbsp;&nbsp;&nbsp;&nbsp;
但是，如果只是通过简单地将层叠加在一起，增加网络深度并不会起到什么作用。随着网络层数的增加，就会出现梯度消失问题，这就会造成网络是难以进行训练，因为梯度反向传播到前层，重复乘法可能使梯度无穷小，这造成的结果就是，随着网络加深，其性能趋于饱和，或者甚至开始迅速退化。

![](./img/ch4/image51.png)

&nbsp;&nbsp;&nbsp;&nbsp; 
增加网络深度导致性能下降

&nbsp;&nbsp;&nbsp;&nbsp;
其实早在ResNet之前，已经有过好几种方法来处理梯度消失问题，例如，在中间层增加辅助损失作为额外的监督，但遗憾的是，似乎没有一个方法可以真正解决这个问题。

&nbsp;&nbsp;&nbsp;&nbsp;
ResNet的核心思想是引入所谓的“恒等映射（identity shortcut connection）”，可以跳过一层或多层，如下图所示：

![](./img/ch4/image52.png)

### 4.8.2 残差块
&nbsp;&nbsp;&nbsp;&nbsp;
[Deep Residual Learning for Image Recognition](https://arxiv.org/pdf/1512.03385v1.pdf)的作者认为，堆积网络层数不应该降低网络性能，因为我们可以简单地在当前网络上堆积身份映射（层不做任何事情），并且所得到的架构将执行相同的操作。这表明，较深的模型所产生的训练误差不应该比较浅的模型高。他们假设让堆积层适应残差映射比使它们直接适应所需的底层映射要容易得多。下图的残差块可以明确地使它做到这一点。

![](./img/ch4/image53.png)

### 4.8.3 ResNet架构

&nbsp;&nbsp;&nbsp;&nbsp;
事实上，ResNet并不是第一个利用short cut、Highway Networks引入门控近路连接的。这些参数化门控制允许多少信息流过近路（shortcut）。类似的想法可以在长短期记忆网络（LSTM）单元中找到，其中存在参数化的忘记门，其控制多少信息将流向下一个时间步。因此，ResNet可以被认为是Highway Networks的一种特殊情况。

&nbsp;&nbsp;&nbsp;&nbsp;
然而，实验表明，Highway Networks的性能并不如ResNet，因为Highway Networks的解决方案空间包含ResNet，因此它应该至少表现得像ResNet一样好。这就表明，保持这些“梯度公路”干净简洁比获取更大的解决方案空间更为重要。

&nbsp;&nbsp;&nbsp;&nbsp;
照着这种直觉，论文作者改进了残差块，并提出了一个残差块的预激活变体，其中梯度可以畅通无阻地通过快速连接到任何其他的前层。论文的实验结果表明，使用原始的残差块，训练1202层ResNet所展示的性能比其训练110层对等物要差得多。

![](./img/ch4/image54.png)

### 4.8.4 ResNeXt

&nbsp;&nbsp;&nbsp;&nbsp;
S. Xie，R. Girshick，P. Dollar，Z. Tu和 K. He在[Aggregated Residual Transformations for Deep Neural Networks](http://openaccess.thecvf.com/content_cvpr_2017/papers/Xie_Aggregated_Residual_Transformations_CVPR_2017_paper.pdf)中提出了一个代号为ResNeXt的ResNet变体，它具有以下构建块：

![](./img/ch4/image55.png)

&nbsp;&nbsp;&nbsp;&nbsp;
左：《Deep Residual Learning for Image Recognition》中所提及的构建块，右图： ResNeXt构建块 基数=32

&nbsp;&nbsp;&nbsp;&nbsp;
这可能看起来很熟悉，因为它非常类似于《IEEE计算机视觉与模式识别会议论文集》中《Going deeper with convolutions》的Inception模块，它们都遵循“拆分-转换-合并”范式，除了在这个变体中，不同路径的输出通过将它们相加在一起而被合并，而在《Going deeper with convolutions》中它们是深度连接的。另一个区别是，在《Going deeper with convolutions》中，每个路径彼此互不相同（1x1,3x3和5x5卷积），而在此架构中，所有路径共享相同的拓扑。

&nbsp;&nbsp;&nbsp;&nbsp;
作者介绍了一个称为 “基数（cardinality）”的超参数——独立路径的数量，以提供调整模型容量的新方式。实验表明，可以通过增加基数，而不是深度或宽度，来更加有效地获得准确度。作者指出，与Inception相比，这种新颖的架构更容易适应新的数据集/任务，因为它具有一个简单的范式，且只有一个超参数被调整，而Inception却具有许多超参数（如每个路径中卷积层内核大小）待调整。

&nbsp;&nbsp;&nbsp;&nbsp;
这个新颖的构建块有如下三种等效形式：

![](./img/ch4/image56.png)

实际上，“分割-变换-合并”通常是通过点分组卷积层来完成的，它将其输入分成特征映射组，并分别执行正常卷积，其输出被深度级联，然后馈送到1x1卷积层。

### 4.8.5 ResNet作为小型网络的组合

&nbsp;&nbsp;&nbsp;&nbsp;
[Deep Networks with Stochastic Depth](https://arxiv.org/pdf/1603.09382.pdf)提出了一种反直觉的方式，训练一个非常深层的网络，通过在训练期间随机丢弃它的层，并在测试时间内使用完整的网络。Veit等人有一个更反直觉的发现：我们实际上可以删除一些已训练的ResNet的一些层，但仍然具有可比性能。这使得ResNet架构更加有趣，该论文亦降低了VGG网络的层，并大大降低了其性能。
该论文首先提供了ResNet的一个简单的视图，使事情更清晰。在我们展开网络架构之后，这是很显而易见的，具有i个残差块的ResNet架构具有$2^{i}$个不同的路径（因为每个残差块提供两个独立的路径）。

![](./img/ch4/image60.jpeg)

&nbsp;&nbsp;&nbsp;&nbsp;
鉴于上述发现，我们很容易发现为什么在ResNet架构中删除几层，对于其性能影响不大——架构具有许多独立的有效路径，在我们删除了几层之后，它们大部分保持不变。相反，VGG网络只有一条有效的路径，所以删除一层是唯一的途径。

&nbsp;&nbsp;&nbsp;&nbsp;
作者还进行了实验，表明ResNet中的路径集合具有集合行为。他们是通过在测试时间删除不同数量的层，然后查看网络的性能是否与已删除层的数量平滑相关，这样的方式做到的。结果表明，网络确实表现得像集合，如下图所示：

![](./img/ch4/image61.png)

### 4.8.6 ResNet中路径的特点

&nbsp;&nbsp;&nbsp;&nbsp;
最后，作者研究了ResNet中路径的特点：

&nbsp;&nbsp;&nbsp;&nbsp;
很明显，所有可能的路径长度的分布都遵循二项式分布，如（a）所示。大多数路径经过19到35个残差块。

![](./img/ch4/image62.png)

&nbsp;&nbsp;&nbsp;&nbsp; 
​	调查路径长度与经过其的梯度大小之间的关系，同时获得长度为k的路径的梯度幅度，作者首先将一批数据馈送给网络，随机抽取k个残差块。当反向传播梯度时，它们仅传播到采样残余块的权重层。（b）表明随着路径变长，梯度的大小迅速下降。

&nbsp;&nbsp;&nbsp;&nbsp;
​	我们现在可以将每个路径长度的频率与其预期的梯度大小相乘，以了解每个长度的路径对于训练有多少帮助，如（c）所示。令人惊讶的是，大多数贡献来自长度为9至18的路径，但它们仅占总路径的一小部分，如（a）所示。这是一个非常有趣的发现，因为它表明ResNet并没有解决长路径上的梯度消失问题，而是通过缩短其有效路径，ResNet实际上能够实现训练非常深度的网络。

&nbsp;&nbsp;&nbsp;&nbsp;
答案来源：[ResNet有多大威力？最近又有了哪些变体？一文弄清](http://www.sohu.com/a/157818653_390227)


## 4.9 为什么现在的CNN模型都是在GoogleNet、VGGNet或者AlexNet上调整的？

- 评测对比：为了让自己的结果更有说服力，在发表自己成果的时候会同一个标准的baseline及在baseline上改进而进行比较，常见的比如各种检测分割的问题都会基于VGG或者Resnet101这样的基础网络。
- 时间和精力有限：在科研压力和工作压力中，时间和精力只允许大家在有限的范围探索。
- 模型创新难度大：进行基本模型的改进需要大量的实验和尝试，并且需要大量的实验积累和强大灵感，很有可能投入产出比比较小。
- 资源限制：创造一个新的模型需要大量的时间和计算资源，往往在学校和小型商业团队不可行。
- 在实际的应用场景中，其实是有大量的非标准模型的配置。

